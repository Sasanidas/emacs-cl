TODO: Come up with a name.

This is an implementation of Common Lisp, written in Emacs Lisp.  It
does not yet purport to conform to the ANSI standard since CLOS,
extended LOOP, pretty printing, and compilation are missing.  However,
most other Common Lisp features like lexical closures, packages,
readtables, multiple values, bignums, adjustable arrays, etc, are
present.  At this stage many bugs remain and error checking is sparse.

See INSTALL for usage instructions.

Some algorithms and messages have been inspired by SBCL.  Notes on the
internals of the implementation follows:



Mapping from Emacs Lisp object types to Common Lisp object types:

EL type			CL type
bit-vector		simple-bit-vector
bool-vector		simple-bit-vector
TODO: character
compiled-function	compiled-function
cons			cons
float			single-float
hash-table		hash-table
integer			fixnum
string			simple-string
subr			compiled-function
symbol			symbol
vector			various, type in first element

Common Lisp objects represented by Emacs Lisp vectors:

bignum			[BIGNUM <n0> <n1> ...]
ratio			[RATIO <numerator> <denominator>]
complex			[COMPLEX <realpart> <imagpart>]
character		[CHARACTER <code>]
string			[STRING <size> <string> <offset> <fill-pointer>]
char-array		[char-array <dimensions> <elements> <offset>]
bit-vector		[BIT-VECTOR <size> <elements> <offset> <fill-pointer>]
bit-array		[bit-array <dimensions> <elements> <offset>]
simple-vector		[SIMPLE-VECTOR <elt> ...]
vector			[VECTOR <size> <elements> <offset> <fill-pointer>]
array			[ARRAY <dimensions> <elements> <offset>]
interpreted-function	[INTERPRETED-FUNCTION <fn> <env> <name>]
instance of class T	[T <slot> ...]



Emacs features wish list:

 * Hash tables.  Done in later versions.

 * Weak hash tables.  Done in later versions.

 * A function that returns the address of an object, for implementing
   print-unreadable-object :identity t.

 * A function that returns the amount of processor time used, for
   implementing get-internal-run-time.

 * A way to portably attach information to byte-code objects.



There are problems with the cl:function macro when its output appears
in compiled files:

 * When applied to a byte-code function the result will be printed
   with the #[...] syntax.  That works, but separate invokations of
   cl:function will result in distinct, though equal, code vectors.

 * When's applied to a subr, the result will be printed with the
   #<subr ...> syntax, which will raise a syntax error when loaded.

In general, Emacs' byte compiler doesn't preserve object identity,
which is a problem.
